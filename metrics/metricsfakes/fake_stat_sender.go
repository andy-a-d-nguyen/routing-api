// Code generated by counterfeiter. DO NOT EDIT.
package metricsfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/routing-api/metrics"
)

type FakeStatSender struct {
	DecStub        func(string, int64, float32) error
	decMutex       sync.RWMutex
	decArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	decReturns struct {
		result1 error
	}
	decReturnsOnCall map[int]struct {
		result1 error
	}
	GaugeStub        func(string, int64, float32) error
	gaugeMutex       sync.RWMutex
	gaugeArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	gaugeReturns struct {
		result1 error
	}
	gaugeReturnsOnCall map[int]struct {
		result1 error
	}
	GaugeDeltaStub        func(string, int64, float32) error
	gaugeDeltaMutex       sync.RWMutex
	gaugeDeltaArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	gaugeDeltaReturns struct {
		result1 error
	}
	gaugeDeltaReturnsOnCall map[int]struct {
		result1 error
	}
	IncStub        func(string, int64, float32) error
	incMutex       sync.RWMutex
	incArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	incReturns struct {
		result1 error
	}
	incReturnsOnCall map[int]struct {
		result1 error
	}
	RawStub        func(string, string, float32) error
	rawMutex       sync.RWMutex
	rawArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 float32
	}
	rawReturns struct {
		result1 error
	}
	rawReturnsOnCall map[int]struct {
		result1 error
	}
	SetStub        func(string, string, float32) error
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 float32
	}
	setReturns struct {
		result1 error
	}
	setReturnsOnCall map[int]struct {
		result1 error
	}
	SetIntStub        func(string, int64, float32) error
	setIntMutex       sync.RWMutex
	setIntArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	setIntReturns struct {
		result1 error
	}
	setIntReturnsOnCall map[int]struct {
		result1 error
	}
	TimingStub        func(string, int64, float32) error
	timingMutex       sync.RWMutex
	timingArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	timingReturns struct {
		result1 error
	}
	timingReturnsOnCall map[int]struct {
		result1 error
	}
	TimingDurationStub        func(string, time.Duration, float32) error
	timingDurationMutex       sync.RWMutex
	timingDurationArgsForCall []struct {
		arg1 string
		arg2 time.Duration
		arg3 float32
	}
	timingDurationReturns struct {
		result1 error
	}
	timingDurationReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStatSender) Dec(arg1 string, arg2 int64, arg3 float32) error {
	fake.decMutex.Lock()
	ret, specificReturn := fake.decReturnsOnCall[len(fake.decArgsForCall)]
	fake.decArgsForCall = append(fake.decArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.DecStub
	fakeReturns := fake.decReturns
	fake.recordInvocation("Dec", []interface{}{arg1, arg2, arg3})
	fake.decMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatSender) DecCallCount() int {
	fake.decMutex.RLock()
	defer fake.decMutex.RUnlock()
	return len(fake.decArgsForCall)
}

func (fake *FakeStatSender) DecCalls(stub func(string, int64, float32) error) {
	fake.decMutex.Lock()
	defer fake.decMutex.Unlock()
	fake.DecStub = stub
}

func (fake *FakeStatSender) DecArgsForCall(i int) (string, int64, float32) {
	fake.decMutex.RLock()
	defer fake.decMutex.RUnlock()
	argsForCall := fake.decArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatSender) DecReturns(result1 error) {
	fake.decMutex.Lock()
	defer fake.decMutex.Unlock()
	fake.DecStub = nil
	fake.decReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) DecReturnsOnCall(i int, result1 error) {
	fake.decMutex.Lock()
	defer fake.decMutex.Unlock()
	fake.DecStub = nil
	if fake.decReturnsOnCall == nil {
		fake.decReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.decReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) Gauge(arg1 string, arg2 int64, arg3 float32) error {
	fake.gaugeMutex.Lock()
	ret, specificReturn := fake.gaugeReturnsOnCall[len(fake.gaugeArgsForCall)]
	fake.gaugeArgsForCall = append(fake.gaugeArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.GaugeStub
	fakeReturns := fake.gaugeReturns
	fake.recordInvocation("Gauge", []interface{}{arg1, arg2, arg3})
	fake.gaugeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatSender) GaugeCallCount() int {
	fake.gaugeMutex.RLock()
	defer fake.gaugeMutex.RUnlock()
	return len(fake.gaugeArgsForCall)
}

func (fake *FakeStatSender) GaugeCalls(stub func(string, int64, float32) error) {
	fake.gaugeMutex.Lock()
	defer fake.gaugeMutex.Unlock()
	fake.GaugeStub = stub
}

func (fake *FakeStatSender) GaugeArgsForCall(i int) (string, int64, float32) {
	fake.gaugeMutex.RLock()
	defer fake.gaugeMutex.RUnlock()
	argsForCall := fake.gaugeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatSender) GaugeReturns(result1 error) {
	fake.gaugeMutex.Lock()
	defer fake.gaugeMutex.Unlock()
	fake.GaugeStub = nil
	fake.gaugeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) GaugeReturnsOnCall(i int, result1 error) {
	fake.gaugeMutex.Lock()
	defer fake.gaugeMutex.Unlock()
	fake.GaugeStub = nil
	if fake.gaugeReturnsOnCall == nil {
		fake.gaugeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.gaugeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) GaugeDelta(arg1 string, arg2 int64, arg3 float32) error {
	fake.gaugeDeltaMutex.Lock()
	ret, specificReturn := fake.gaugeDeltaReturnsOnCall[len(fake.gaugeDeltaArgsForCall)]
	fake.gaugeDeltaArgsForCall = append(fake.gaugeDeltaArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.GaugeDeltaStub
	fakeReturns := fake.gaugeDeltaReturns
	fake.recordInvocation("GaugeDelta", []interface{}{arg1, arg2, arg3})
	fake.gaugeDeltaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatSender) GaugeDeltaCallCount() int {
	fake.gaugeDeltaMutex.RLock()
	defer fake.gaugeDeltaMutex.RUnlock()
	return len(fake.gaugeDeltaArgsForCall)
}

func (fake *FakeStatSender) GaugeDeltaCalls(stub func(string, int64, float32) error) {
	fake.gaugeDeltaMutex.Lock()
	defer fake.gaugeDeltaMutex.Unlock()
	fake.GaugeDeltaStub = stub
}

func (fake *FakeStatSender) GaugeDeltaArgsForCall(i int) (string, int64, float32) {
	fake.gaugeDeltaMutex.RLock()
	defer fake.gaugeDeltaMutex.RUnlock()
	argsForCall := fake.gaugeDeltaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatSender) GaugeDeltaReturns(result1 error) {
	fake.gaugeDeltaMutex.Lock()
	defer fake.gaugeDeltaMutex.Unlock()
	fake.GaugeDeltaStub = nil
	fake.gaugeDeltaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) GaugeDeltaReturnsOnCall(i int, result1 error) {
	fake.gaugeDeltaMutex.Lock()
	defer fake.gaugeDeltaMutex.Unlock()
	fake.GaugeDeltaStub = nil
	if fake.gaugeDeltaReturnsOnCall == nil {
		fake.gaugeDeltaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.gaugeDeltaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) Inc(arg1 string, arg2 int64, arg3 float32) error {
	fake.incMutex.Lock()
	ret, specificReturn := fake.incReturnsOnCall[len(fake.incArgsForCall)]
	fake.incArgsForCall = append(fake.incArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.IncStub
	fakeReturns := fake.incReturns
	fake.recordInvocation("Inc", []interface{}{arg1, arg2, arg3})
	fake.incMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatSender) IncCallCount() int {
	fake.incMutex.RLock()
	defer fake.incMutex.RUnlock()
	return len(fake.incArgsForCall)
}

func (fake *FakeStatSender) IncCalls(stub func(string, int64, float32) error) {
	fake.incMutex.Lock()
	defer fake.incMutex.Unlock()
	fake.IncStub = stub
}

func (fake *FakeStatSender) IncArgsForCall(i int) (string, int64, float32) {
	fake.incMutex.RLock()
	defer fake.incMutex.RUnlock()
	argsForCall := fake.incArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatSender) IncReturns(result1 error) {
	fake.incMutex.Lock()
	defer fake.incMutex.Unlock()
	fake.IncStub = nil
	fake.incReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) IncReturnsOnCall(i int, result1 error) {
	fake.incMutex.Lock()
	defer fake.incMutex.Unlock()
	fake.IncStub = nil
	if fake.incReturnsOnCall == nil {
		fake.incReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.incReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) Raw(arg1 string, arg2 string, arg3 float32) error {
	fake.rawMutex.Lock()
	ret, specificReturn := fake.rawReturnsOnCall[len(fake.rawArgsForCall)]
	fake.rawArgsForCall = append(fake.rawArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.RawStub
	fakeReturns := fake.rawReturns
	fake.recordInvocation("Raw", []interface{}{arg1, arg2, arg3})
	fake.rawMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatSender) RawCallCount() int {
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	return len(fake.rawArgsForCall)
}

func (fake *FakeStatSender) RawCalls(stub func(string, string, float32) error) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = stub
}

func (fake *FakeStatSender) RawArgsForCall(i int) (string, string, float32) {
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	argsForCall := fake.rawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatSender) RawReturns(result1 error) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = nil
	fake.rawReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) RawReturnsOnCall(i int, result1 error) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = nil
	if fake.rawReturnsOnCall == nil {
		fake.rawReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rawReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) Set(arg1 string, arg2 string, arg3 float32) error {
	fake.setMutex.Lock()
	ret, specificReturn := fake.setReturnsOnCall[len(fake.setArgsForCall)]
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.SetStub
	fakeReturns := fake.setReturns
	fake.recordInvocation("Set", []interface{}{arg1, arg2, arg3})
	fake.setMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatSender) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakeStatSender) SetCalls(stub func(string, string, float32) error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = stub
}

func (fake *FakeStatSender) SetArgsForCall(i int) (string, string, float32) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	argsForCall := fake.setArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatSender) SetReturns(result1 error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) SetReturnsOnCall(i int, result1 error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	if fake.setReturnsOnCall == nil {
		fake.setReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) SetInt(arg1 string, arg2 int64, arg3 float32) error {
	fake.setIntMutex.Lock()
	ret, specificReturn := fake.setIntReturnsOnCall[len(fake.setIntArgsForCall)]
	fake.setIntArgsForCall = append(fake.setIntArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.SetIntStub
	fakeReturns := fake.setIntReturns
	fake.recordInvocation("SetInt", []interface{}{arg1, arg2, arg3})
	fake.setIntMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatSender) SetIntCallCount() int {
	fake.setIntMutex.RLock()
	defer fake.setIntMutex.RUnlock()
	return len(fake.setIntArgsForCall)
}

func (fake *FakeStatSender) SetIntCalls(stub func(string, int64, float32) error) {
	fake.setIntMutex.Lock()
	defer fake.setIntMutex.Unlock()
	fake.SetIntStub = stub
}

func (fake *FakeStatSender) SetIntArgsForCall(i int) (string, int64, float32) {
	fake.setIntMutex.RLock()
	defer fake.setIntMutex.RUnlock()
	argsForCall := fake.setIntArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatSender) SetIntReturns(result1 error) {
	fake.setIntMutex.Lock()
	defer fake.setIntMutex.Unlock()
	fake.SetIntStub = nil
	fake.setIntReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) SetIntReturnsOnCall(i int, result1 error) {
	fake.setIntMutex.Lock()
	defer fake.setIntMutex.Unlock()
	fake.SetIntStub = nil
	if fake.setIntReturnsOnCall == nil {
		fake.setIntReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setIntReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) Timing(arg1 string, arg2 int64, arg3 float32) error {
	fake.timingMutex.Lock()
	ret, specificReturn := fake.timingReturnsOnCall[len(fake.timingArgsForCall)]
	fake.timingArgsForCall = append(fake.timingArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.TimingStub
	fakeReturns := fake.timingReturns
	fake.recordInvocation("Timing", []interface{}{arg1, arg2, arg3})
	fake.timingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatSender) TimingCallCount() int {
	fake.timingMutex.RLock()
	defer fake.timingMutex.RUnlock()
	return len(fake.timingArgsForCall)
}

func (fake *FakeStatSender) TimingCalls(stub func(string, int64, float32) error) {
	fake.timingMutex.Lock()
	defer fake.timingMutex.Unlock()
	fake.TimingStub = stub
}

func (fake *FakeStatSender) TimingArgsForCall(i int) (string, int64, float32) {
	fake.timingMutex.RLock()
	defer fake.timingMutex.RUnlock()
	argsForCall := fake.timingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatSender) TimingReturns(result1 error) {
	fake.timingMutex.Lock()
	defer fake.timingMutex.Unlock()
	fake.TimingStub = nil
	fake.timingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) TimingReturnsOnCall(i int, result1 error) {
	fake.timingMutex.Lock()
	defer fake.timingMutex.Unlock()
	fake.TimingStub = nil
	if fake.timingReturnsOnCall == nil {
		fake.timingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.timingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) TimingDuration(arg1 string, arg2 time.Duration, arg3 float32) error {
	fake.timingDurationMutex.Lock()
	ret, specificReturn := fake.timingDurationReturnsOnCall[len(fake.timingDurationArgsForCall)]
	fake.timingDurationArgsForCall = append(fake.timingDurationArgsForCall, struct {
		arg1 string
		arg2 time.Duration
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.TimingDurationStub
	fakeReturns := fake.timingDurationReturns
	fake.recordInvocation("TimingDuration", []interface{}{arg1, arg2, arg3})
	fake.timingDurationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatSender) TimingDurationCallCount() int {
	fake.timingDurationMutex.RLock()
	defer fake.timingDurationMutex.RUnlock()
	return len(fake.timingDurationArgsForCall)
}

func (fake *FakeStatSender) TimingDurationCalls(stub func(string, time.Duration, float32) error) {
	fake.timingDurationMutex.Lock()
	defer fake.timingDurationMutex.Unlock()
	fake.TimingDurationStub = stub
}

func (fake *FakeStatSender) TimingDurationArgsForCall(i int) (string, time.Duration, float32) {
	fake.timingDurationMutex.RLock()
	defer fake.timingDurationMutex.RUnlock()
	argsForCall := fake.timingDurationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatSender) TimingDurationReturns(result1 error) {
	fake.timingDurationMutex.Lock()
	defer fake.timingDurationMutex.Unlock()
	fake.TimingDurationStub = nil
	fake.timingDurationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) TimingDurationReturnsOnCall(i int, result1 error) {
	fake.timingDurationMutex.Lock()
	defer fake.timingDurationMutex.Unlock()
	fake.TimingDurationStub = nil
	if fake.timingDurationReturnsOnCall == nil {
		fake.timingDurationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.timingDurationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatSender) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.decMutex.RLock()
	defer fake.decMutex.RUnlock()
	fake.gaugeMutex.RLock()
	defer fake.gaugeMutex.RUnlock()
	fake.gaugeDeltaMutex.RLock()
	defer fake.gaugeDeltaMutex.RUnlock()
	fake.incMutex.RLock()
	defer fake.incMutex.RUnlock()
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	fake.setIntMutex.RLock()
	defer fake.setIntMutex.RUnlock()
	fake.timingMutex.RLock()
	defer fake.timingMutex.RUnlock()
	fake.timingDurationMutex.RLock()
	defer fake.timingDurationMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStatSender) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ metrics.StatSender = new(FakeStatSender)
