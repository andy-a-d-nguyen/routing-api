// Code generated by counterfeiter. DO NOT EDIT.
package metricsfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/routing-api/metrics"
)

type FakeStatter struct {
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	DecStub        func(string, int64, float32) error
	decMutex       sync.RWMutex
	decArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	decReturns struct {
		result1 error
	}
	decReturnsOnCall map[int]struct {
		result1 error
	}
	GaugeStub        func(string, int64, float32) error
	gaugeMutex       sync.RWMutex
	gaugeArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	gaugeReturns struct {
		result1 error
	}
	gaugeReturnsOnCall map[int]struct {
		result1 error
	}
	GaugeDeltaStub        func(string, int64, float32) error
	gaugeDeltaMutex       sync.RWMutex
	gaugeDeltaArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	gaugeDeltaReturns struct {
		result1 error
	}
	gaugeDeltaReturnsOnCall map[int]struct {
		result1 error
	}
	IncStub        func(string, int64, float32) error
	incMutex       sync.RWMutex
	incArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	incReturns struct {
		result1 error
	}
	incReturnsOnCall map[int]struct {
		result1 error
	}
	NewSubStatterStub        func(string) metrics.SubStatter
	newSubStatterMutex       sync.RWMutex
	newSubStatterArgsForCall []struct {
		arg1 string
	}
	newSubStatterReturns struct {
		result1 metrics.SubStatter
	}
	newSubStatterReturnsOnCall map[int]struct {
		result1 metrics.SubStatter
	}
	RawStub        func(string, string, float32) error
	rawMutex       sync.RWMutex
	rawArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 float32
	}
	rawReturns struct {
		result1 error
	}
	rawReturnsOnCall map[int]struct {
		result1 error
	}
	SetStub        func(string, string, float32) error
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 float32
	}
	setReturns struct {
		result1 error
	}
	setReturnsOnCall map[int]struct {
		result1 error
	}
	SetIntStub        func(string, int64, float32) error
	setIntMutex       sync.RWMutex
	setIntArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	setIntReturns struct {
		result1 error
	}
	setIntReturnsOnCall map[int]struct {
		result1 error
	}
	SetPrefixStub        func(string)
	setPrefixMutex       sync.RWMutex
	setPrefixArgsForCall []struct {
		arg1 string
	}
	TimingStub        func(string, int64, float32) error
	timingMutex       sync.RWMutex
	timingArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 float32
	}
	timingReturns struct {
		result1 error
	}
	timingReturnsOnCall map[int]struct {
		result1 error
	}
	TimingDurationStub        func(string, time.Duration, float32) error
	timingDurationMutex       sync.RWMutex
	timingDurationArgsForCall []struct {
		arg1 string
		arg2 time.Duration
		arg3 float32
	}
	timingDurationReturns struct {
		result1 error
	}
	timingDurationReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStatter) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeStatter) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeStatter) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) Dec(arg1 string, arg2 int64, arg3 float32) error {
	fake.decMutex.Lock()
	ret, specificReturn := fake.decReturnsOnCall[len(fake.decArgsForCall)]
	fake.decArgsForCall = append(fake.decArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.DecStub
	fakeReturns := fake.decReturns
	fake.recordInvocation("Dec", []interface{}{arg1, arg2, arg3})
	fake.decMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) DecCallCount() int {
	fake.decMutex.RLock()
	defer fake.decMutex.RUnlock()
	return len(fake.decArgsForCall)
}

func (fake *FakeStatter) DecCalls(stub func(string, int64, float32) error) {
	fake.decMutex.Lock()
	defer fake.decMutex.Unlock()
	fake.DecStub = stub
}

func (fake *FakeStatter) DecArgsForCall(i int) (string, int64, float32) {
	fake.decMutex.RLock()
	defer fake.decMutex.RUnlock()
	argsForCall := fake.decArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatter) DecReturns(result1 error) {
	fake.decMutex.Lock()
	defer fake.decMutex.Unlock()
	fake.DecStub = nil
	fake.decReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) DecReturnsOnCall(i int, result1 error) {
	fake.decMutex.Lock()
	defer fake.decMutex.Unlock()
	fake.DecStub = nil
	if fake.decReturnsOnCall == nil {
		fake.decReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.decReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) Gauge(arg1 string, arg2 int64, arg3 float32) error {
	fake.gaugeMutex.Lock()
	ret, specificReturn := fake.gaugeReturnsOnCall[len(fake.gaugeArgsForCall)]
	fake.gaugeArgsForCall = append(fake.gaugeArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.GaugeStub
	fakeReturns := fake.gaugeReturns
	fake.recordInvocation("Gauge", []interface{}{arg1, arg2, arg3})
	fake.gaugeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) GaugeCallCount() int {
	fake.gaugeMutex.RLock()
	defer fake.gaugeMutex.RUnlock()
	return len(fake.gaugeArgsForCall)
}

func (fake *FakeStatter) GaugeCalls(stub func(string, int64, float32) error) {
	fake.gaugeMutex.Lock()
	defer fake.gaugeMutex.Unlock()
	fake.GaugeStub = stub
}

func (fake *FakeStatter) GaugeArgsForCall(i int) (string, int64, float32) {
	fake.gaugeMutex.RLock()
	defer fake.gaugeMutex.RUnlock()
	argsForCall := fake.gaugeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatter) GaugeReturns(result1 error) {
	fake.gaugeMutex.Lock()
	defer fake.gaugeMutex.Unlock()
	fake.GaugeStub = nil
	fake.gaugeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) GaugeReturnsOnCall(i int, result1 error) {
	fake.gaugeMutex.Lock()
	defer fake.gaugeMutex.Unlock()
	fake.GaugeStub = nil
	if fake.gaugeReturnsOnCall == nil {
		fake.gaugeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.gaugeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) GaugeDelta(arg1 string, arg2 int64, arg3 float32) error {
	fake.gaugeDeltaMutex.Lock()
	ret, specificReturn := fake.gaugeDeltaReturnsOnCall[len(fake.gaugeDeltaArgsForCall)]
	fake.gaugeDeltaArgsForCall = append(fake.gaugeDeltaArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.GaugeDeltaStub
	fakeReturns := fake.gaugeDeltaReturns
	fake.recordInvocation("GaugeDelta", []interface{}{arg1, arg2, arg3})
	fake.gaugeDeltaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) GaugeDeltaCallCount() int {
	fake.gaugeDeltaMutex.RLock()
	defer fake.gaugeDeltaMutex.RUnlock()
	return len(fake.gaugeDeltaArgsForCall)
}

func (fake *FakeStatter) GaugeDeltaCalls(stub func(string, int64, float32) error) {
	fake.gaugeDeltaMutex.Lock()
	defer fake.gaugeDeltaMutex.Unlock()
	fake.GaugeDeltaStub = stub
}

func (fake *FakeStatter) GaugeDeltaArgsForCall(i int) (string, int64, float32) {
	fake.gaugeDeltaMutex.RLock()
	defer fake.gaugeDeltaMutex.RUnlock()
	argsForCall := fake.gaugeDeltaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatter) GaugeDeltaReturns(result1 error) {
	fake.gaugeDeltaMutex.Lock()
	defer fake.gaugeDeltaMutex.Unlock()
	fake.GaugeDeltaStub = nil
	fake.gaugeDeltaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) GaugeDeltaReturnsOnCall(i int, result1 error) {
	fake.gaugeDeltaMutex.Lock()
	defer fake.gaugeDeltaMutex.Unlock()
	fake.GaugeDeltaStub = nil
	if fake.gaugeDeltaReturnsOnCall == nil {
		fake.gaugeDeltaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.gaugeDeltaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) Inc(arg1 string, arg2 int64, arg3 float32) error {
	fake.incMutex.Lock()
	ret, specificReturn := fake.incReturnsOnCall[len(fake.incArgsForCall)]
	fake.incArgsForCall = append(fake.incArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.IncStub
	fakeReturns := fake.incReturns
	fake.recordInvocation("Inc", []interface{}{arg1, arg2, arg3})
	fake.incMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) IncCallCount() int {
	fake.incMutex.RLock()
	defer fake.incMutex.RUnlock()
	return len(fake.incArgsForCall)
}

func (fake *FakeStatter) IncCalls(stub func(string, int64, float32) error) {
	fake.incMutex.Lock()
	defer fake.incMutex.Unlock()
	fake.IncStub = stub
}

func (fake *FakeStatter) IncArgsForCall(i int) (string, int64, float32) {
	fake.incMutex.RLock()
	defer fake.incMutex.RUnlock()
	argsForCall := fake.incArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatter) IncReturns(result1 error) {
	fake.incMutex.Lock()
	defer fake.incMutex.Unlock()
	fake.IncStub = nil
	fake.incReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) IncReturnsOnCall(i int, result1 error) {
	fake.incMutex.Lock()
	defer fake.incMutex.Unlock()
	fake.IncStub = nil
	if fake.incReturnsOnCall == nil {
		fake.incReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.incReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) NewSubStatter(arg1 string) metrics.SubStatter {
	fake.newSubStatterMutex.Lock()
	ret, specificReturn := fake.newSubStatterReturnsOnCall[len(fake.newSubStatterArgsForCall)]
	fake.newSubStatterArgsForCall = append(fake.newSubStatterArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.NewSubStatterStub
	fakeReturns := fake.newSubStatterReturns
	fake.recordInvocation("NewSubStatter", []interface{}{arg1})
	fake.newSubStatterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) NewSubStatterCallCount() int {
	fake.newSubStatterMutex.RLock()
	defer fake.newSubStatterMutex.RUnlock()
	return len(fake.newSubStatterArgsForCall)
}

func (fake *FakeStatter) NewSubStatterCalls(stub func(string) metrics.SubStatter) {
	fake.newSubStatterMutex.Lock()
	defer fake.newSubStatterMutex.Unlock()
	fake.NewSubStatterStub = stub
}

func (fake *FakeStatter) NewSubStatterArgsForCall(i int) string {
	fake.newSubStatterMutex.RLock()
	defer fake.newSubStatterMutex.RUnlock()
	argsForCall := fake.newSubStatterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStatter) NewSubStatterReturns(result1 metrics.SubStatter) {
	fake.newSubStatterMutex.Lock()
	defer fake.newSubStatterMutex.Unlock()
	fake.NewSubStatterStub = nil
	fake.newSubStatterReturns = struct {
		result1 metrics.SubStatter
	}{result1}
}

func (fake *FakeStatter) NewSubStatterReturnsOnCall(i int, result1 metrics.SubStatter) {
	fake.newSubStatterMutex.Lock()
	defer fake.newSubStatterMutex.Unlock()
	fake.NewSubStatterStub = nil
	if fake.newSubStatterReturnsOnCall == nil {
		fake.newSubStatterReturnsOnCall = make(map[int]struct {
			result1 metrics.SubStatter
		})
	}
	fake.newSubStatterReturnsOnCall[i] = struct {
		result1 metrics.SubStatter
	}{result1}
}

func (fake *FakeStatter) Raw(arg1 string, arg2 string, arg3 float32) error {
	fake.rawMutex.Lock()
	ret, specificReturn := fake.rawReturnsOnCall[len(fake.rawArgsForCall)]
	fake.rawArgsForCall = append(fake.rawArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.RawStub
	fakeReturns := fake.rawReturns
	fake.recordInvocation("Raw", []interface{}{arg1, arg2, arg3})
	fake.rawMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) RawCallCount() int {
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	return len(fake.rawArgsForCall)
}

func (fake *FakeStatter) RawCalls(stub func(string, string, float32) error) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = stub
}

func (fake *FakeStatter) RawArgsForCall(i int) (string, string, float32) {
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	argsForCall := fake.rawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatter) RawReturns(result1 error) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = nil
	fake.rawReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) RawReturnsOnCall(i int, result1 error) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = nil
	if fake.rawReturnsOnCall == nil {
		fake.rawReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rawReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) Set(arg1 string, arg2 string, arg3 float32) error {
	fake.setMutex.Lock()
	ret, specificReturn := fake.setReturnsOnCall[len(fake.setArgsForCall)]
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.SetStub
	fakeReturns := fake.setReturns
	fake.recordInvocation("Set", []interface{}{arg1, arg2, arg3})
	fake.setMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakeStatter) SetCalls(stub func(string, string, float32) error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = stub
}

func (fake *FakeStatter) SetArgsForCall(i int) (string, string, float32) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	argsForCall := fake.setArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatter) SetReturns(result1 error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) SetReturnsOnCall(i int, result1 error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	if fake.setReturnsOnCall == nil {
		fake.setReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) SetInt(arg1 string, arg2 int64, arg3 float32) error {
	fake.setIntMutex.Lock()
	ret, specificReturn := fake.setIntReturnsOnCall[len(fake.setIntArgsForCall)]
	fake.setIntArgsForCall = append(fake.setIntArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.SetIntStub
	fakeReturns := fake.setIntReturns
	fake.recordInvocation("SetInt", []interface{}{arg1, arg2, arg3})
	fake.setIntMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) SetIntCallCount() int {
	fake.setIntMutex.RLock()
	defer fake.setIntMutex.RUnlock()
	return len(fake.setIntArgsForCall)
}

func (fake *FakeStatter) SetIntCalls(stub func(string, int64, float32) error) {
	fake.setIntMutex.Lock()
	defer fake.setIntMutex.Unlock()
	fake.SetIntStub = stub
}

func (fake *FakeStatter) SetIntArgsForCall(i int) (string, int64, float32) {
	fake.setIntMutex.RLock()
	defer fake.setIntMutex.RUnlock()
	argsForCall := fake.setIntArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatter) SetIntReturns(result1 error) {
	fake.setIntMutex.Lock()
	defer fake.setIntMutex.Unlock()
	fake.SetIntStub = nil
	fake.setIntReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) SetIntReturnsOnCall(i int, result1 error) {
	fake.setIntMutex.Lock()
	defer fake.setIntMutex.Unlock()
	fake.SetIntStub = nil
	if fake.setIntReturnsOnCall == nil {
		fake.setIntReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setIntReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) SetPrefix(arg1 string) {
	fake.setPrefixMutex.Lock()
	fake.setPrefixArgsForCall = append(fake.setPrefixArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetPrefixStub
	fake.recordInvocation("SetPrefix", []interface{}{arg1})
	fake.setPrefixMutex.Unlock()
	if stub != nil {
		fake.SetPrefixStub(arg1)
	}
}

func (fake *FakeStatter) SetPrefixCallCount() int {
	fake.setPrefixMutex.RLock()
	defer fake.setPrefixMutex.RUnlock()
	return len(fake.setPrefixArgsForCall)
}

func (fake *FakeStatter) SetPrefixCalls(stub func(string)) {
	fake.setPrefixMutex.Lock()
	defer fake.setPrefixMutex.Unlock()
	fake.SetPrefixStub = stub
}

func (fake *FakeStatter) SetPrefixArgsForCall(i int) string {
	fake.setPrefixMutex.RLock()
	defer fake.setPrefixMutex.RUnlock()
	argsForCall := fake.setPrefixArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStatter) Timing(arg1 string, arg2 int64, arg3 float32) error {
	fake.timingMutex.Lock()
	ret, specificReturn := fake.timingReturnsOnCall[len(fake.timingArgsForCall)]
	fake.timingArgsForCall = append(fake.timingArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.TimingStub
	fakeReturns := fake.timingReturns
	fake.recordInvocation("Timing", []interface{}{arg1, arg2, arg3})
	fake.timingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) TimingCallCount() int {
	fake.timingMutex.RLock()
	defer fake.timingMutex.RUnlock()
	return len(fake.timingArgsForCall)
}

func (fake *FakeStatter) TimingCalls(stub func(string, int64, float32) error) {
	fake.timingMutex.Lock()
	defer fake.timingMutex.Unlock()
	fake.TimingStub = stub
}

func (fake *FakeStatter) TimingArgsForCall(i int) (string, int64, float32) {
	fake.timingMutex.RLock()
	defer fake.timingMutex.RUnlock()
	argsForCall := fake.timingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatter) TimingReturns(result1 error) {
	fake.timingMutex.Lock()
	defer fake.timingMutex.Unlock()
	fake.TimingStub = nil
	fake.timingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) TimingReturnsOnCall(i int, result1 error) {
	fake.timingMutex.Lock()
	defer fake.timingMutex.Unlock()
	fake.TimingStub = nil
	if fake.timingReturnsOnCall == nil {
		fake.timingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.timingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) TimingDuration(arg1 string, arg2 time.Duration, arg3 float32) error {
	fake.timingDurationMutex.Lock()
	ret, specificReturn := fake.timingDurationReturnsOnCall[len(fake.timingDurationArgsForCall)]
	fake.timingDurationArgsForCall = append(fake.timingDurationArgsForCall, struct {
		arg1 string
		arg2 time.Duration
		arg3 float32
	}{arg1, arg2, arg3})
	stub := fake.TimingDurationStub
	fakeReturns := fake.timingDurationReturns
	fake.recordInvocation("TimingDuration", []interface{}{arg1, arg2, arg3})
	fake.timingDurationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStatter) TimingDurationCallCount() int {
	fake.timingDurationMutex.RLock()
	defer fake.timingDurationMutex.RUnlock()
	return len(fake.timingDurationArgsForCall)
}

func (fake *FakeStatter) TimingDurationCalls(stub func(string, time.Duration, float32) error) {
	fake.timingDurationMutex.Lock()
	defer fake.timingDurationMutex.Unlock()
	fake.TimingDurationStub = stub
}

func (fake *FakeStatter) TimingDurationArgsForCall(i int) (string, time.Duration, float32) {
	fake.timingDurationMutex.RLock()
	defer fake.timingDurationMutex.RUnlock()
	argsForCall := fake.timingDurationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStatter) TimingDurationReturns(result1 error) {
	fake.timingDurationMutex.Lock()
	defer fake.timingDurationMutex.Unlock()
	fake.TimingDurationStub = nil
	fake.timingDurationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) TimingDurationReturnsOnCall(i int, result1 error) {
	fake.timingDurationMutex.Lock()
	defer fake.timingDurationMutex.Unlock()
	fake.TimingDurationStub = nil
	if fake.timingDurationReturnsOnCall == nil {
		fake.timingDurationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.timingDurationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.decMutex.RLock()
	defer fake.decMutex.RUnlock()
	fake.gaugeMutex.RLock()
	defer fake.gaugeMutex.RUnlock()
	fake.gaugeDeltaMutex.RLock()
	defer fake.gaugeDeltaMutex.RUnlock()
	fake.incMutex.RLock()
	defer fake.incMutex.RUnlock()
	fake.newSubStatterMutex.RLock()
	defer fake.newSubStatterMutex.RUnlock()
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	fake.setIntMutex.RLock()
	defer fake.setIntMutex.RUnlock()
	fake.setPrefixMutex.RLock()
	defer fake.setPrefixMutex.RUnlock()
	fake.timingMutex.RLock()
	defer fake.timingMutex.RUnlock()
	fake.timingDurationMutex.RLock()
	defer fake.timingDurationMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStatter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ metrics.Statter = new(FakeStatter)
